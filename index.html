<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Крестики-Нолики Расширение</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
    <script src="https://unpkg.com/@tanstack/react-query@4.36.1/build/umd/index.production.js"></script>
    <script src="https://unpkg.com/react-swipeable@7.0.1/lib/umd/react-swipeable.min.js"></script>

    <style>
        /* Общие стили и сброс */
        body, html {
            margin: 0;
            padding: 0;
            font-family: 'Inter', Arial, sans-serif;
            background-color: #f4f7f9;
            color: #333;
            width: 420px; 
            overflow-x: hidden;
        }

        #root {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        button {
            cursor: pointer;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 16px;
            border: none;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        button:hover:not(:disabled) {
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        input[type="text"], input[type="file"] {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            font-size: 14px;
            box-sizing: border-box;
        }

        /* Стили из App.css */
        .app-container {
            width: 100%;
            max-width: 400px; 
            padding: 20px;
            box-sizing: border-box;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin: 10px;
        }

        .app-container h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 28px;
            font-weight: 600;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 25px auto;
            width: 100%;
            max-width: 300px;
        }

        .cell {
            width: 100%; 
            aspect-ratio: 1 / 1; 
            font-size: 2.5em; 
            font-weight: bold;
            background: #ecf0f1;
            border: 2px solid #bdc3c7;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #34495e;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .cell:hover:not(:disabled) {
            background: #dfe6e9;
            transform: scale(1.03);
        }
        .cell:active:not(:disabled) {
            transform: scale(0.97);
        }

        .winner-section { /* Общий контейнер для результатов игры и кнопки анализа */
            text-align: center;
            margin-top: 20px;
        }

        .winner {
            font-size: 1.5em;
            color: #27ae60;
            font-weight: 500;
            margin-bottom: 10px; /* Отступ перед кнопкой "Новая игра" */
        }
        .winner.draw {
            color: #f39c12;
        }

        .winner-section button, .gemini-feature button {
            margin-top: 10px;
            padding: 10px 20px; 
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9em; 
        }
        .winner-section button:hover, .gemini-feature button:hover:not(:disabled) {
            background: #2980b9;
        }
        .gemini-feature button {
            background-color: #9b59b6; 
        }
        .gemini-feature button:hover:not(:disabled) {
            background-color: #8e44ad;
        }


        .status {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #7f8c8d;
            height: 20px; 
        }
        
        .gemini-analysis {
            margin-top: 15px;
            padding: 10px;
            background-color: #f0e6f6;
            border-radius: 8px;
            font-style: italic;
            color: #5b327c;
            border: 1px solid #d8bfde;
            font-size: 0.95em;
            min-height: 30px;
        }


        /* Стили из Chat.css */
        .chat-section-title {
            text-align: center;
            font-size: 1.5em;
            color: #2c3e50;
            margin-top: 30px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .chat-container {
            display: flex;
            flex-direction: column;
            height: 350px; 
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            background-color: #f9f9f9;
            margin-top: 20px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .chat-messages::-webkit-scrollbar { width: 8px; }
        .chat-messages::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .chat-messages::-webkit-scrollbar-thumb { background: #c5c5c5; border-radius: 10px; }
        .chat-messages::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }


        .message {
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 75%;
            word-wrap: break-word;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            position: relative; 
        }
        .message p { margin: 0; line-height: 1.4; }
        .message img {
            max-width: 100%;
            max-height: 150px; 
            border-radius: 10px;
            margin-top: 5px;
            display: block;
            background-color: #eee; 
        }

        .message.sent {
            background: #3498db; 
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 5px; 
        }

        .message.received {
            background: #e9ecef; 
            color: #333;
            margin-right: auto;
            border-bottom-left-radius: 5px; 
        }
        
        .message-meta {
            font-size: 0.75em;
            color: rgba(0,0,0,0.5);
            margin-top: 5px;
        }
        .message.sent .message-meta { color: rgba(255,255,255,0.7); }


        .chat-input-area { 
            padding: 15px;
            background: #ffffff;
            border-top: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .chat-input-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input-controls input[type="text"] {
            flex: 1;
            padding: 12px;
            border: 1px solid #dcdcdc;
            border-radius: 20px; 
            font-size: 15px;
        }
        .chat-input-controls input[type="text"]:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .chat-input-controls button { 
            padding: 10px 15px; 
            background: #2ecc71; 
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 14px; 
            font-weight: 500;
            min-width: 40px; 
            text-align: center;
        }
        .chat-input-controls button.gemini-chat-btn { 
             background: #9b59b6; 
        }
        .chat-input-controls button.gemini-chat-btn:hover:not(:disabled) {
            background: #8e44ad;
        }
        .chat-input-controls button:hover:not(:disabled) {
            background: #27ae60;
        }
        
        .chat-input-controls input[type="file"] { display: none; }
        .file-upload-label {
            padding: 10px 12px;
            background-color: #f0f0f0;
            color: #555;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
            line-height: 1; 
        }
        .file-upload-label:hover { background-color: #e0e0e0; }


        .reply-preview {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid #3498db;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #555;
        }
        .reply-preview span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80%;
        }
        .reply-preview button { 
            background: none;
            border: none;
            color: #999;
            font-size: 1.2em;
            padding: 0 5px;
            box-shadow: none;
        }
        .reply-preview button:hover { color: #333; }

        .image-preview-container {
            position: relative;
            margin-bottom: 10px;
            max-width: 150px; 
        }
        .image-preview-container img {
            max-width: 100%;
            max-height: 100px;
            border-radius: 8px;
            border: 1px solid #ddd;
            display: block;
        }
        .remove-image-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            line-height: 20px;
            text-align: center;
            padding: 0;
            box-shadow: none;
        }
        .loading-indicator, .error-indicator {
            text-align: center;
            padding: 10px; 
            font-size: 1em; 
            color: #7f8c8d;
        }
        .error-indicator { color: #e74c3c; }

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Оборачиваем весь код в window.onload для гарантии загрузки всех CDN скриптов
        window.onload = function() {
            // Замените на URL вашего реального сервера для чата
            const API_BASE_URL = 'http://localhost:3000'; 
            // const API_BASE_URL = 'https://your-replit-project-name.repl.co';

            const { useState, useEffect, useRef, StrictMode } = React;
            const { QueryClient, QueryClientProvider, useQuery, useMutation, useQueryClient: useTanQueryClient } = ReactQuery; 
            
            // Теперь ReactSwipeable должен быть доступен в window
            const { useSwipeable } = window.ReactSwipeable || {}; // Добавим || {} для большей безопасности, если вдруг что-то пойдет не так

            // --- Gemini API Helper ---
            async function generateTextFromGemini(promptText) {
                const apiKey = ""; // API ключ будет обработан средой Canvas
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const payload = {
                    contents: [{
                        role: "user",
                        parts: [{ text: promptText }]
                    }],
                    generationConfig: { 
                        temperature: 0.7,
                        maxOutputTokens: 150, 
                    }
                };

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        console.error("Gemini API Error Response:", errorData);
                        const message = errorData.error?.message || response.statusText;
                        if (response.status === 429) { 
                            throw new Error(`Слишком много запросов к Gemini API. Попробуйте позже. (${response.status})`);
                        }
                        throw new Error(`Ошибка Gemini API: ${message} (${response.status})`);
                    }

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        return result.candidates[0].content.parts[0].text.trim();
                    } else {
                        console.error("Неожиданная структура ответа Gemini API:", result);
                        if (result.promptFeedback && result.promptFeedback.blockReason) {
                            throw new Error(`Запрос к Gemini был заблокирован: ${result.promptFeedback.blockReason} ${result.promptFeedback.blockReasonMessage || ''}. Пожалуйста, измените запрос.`);
                        }
                        throw new Error("Не удалось получить текст из ответа Gemini.");
                    }
                } catch (error) {
                    console.error('Ошибка вызова Gemini API:', error);
                    throw error; 
                }
            }


            // --- Компонент игры "Крестики-Нолики" ---
            const TicTacToeGame = () => {
                const [board, setBoard] = useState(Array(9).fill(null));
                const [isXTurn, setIsXTurn] = useState(true);
                const [winner, setWinner] = useState(null);
                const [statusMessage, setStatusMessage] = useState('Ход игрока X');
                const [gameAnalysis, setGameAnalysis] = useState('');
                const [isAnalyzingGame, setIsAnalyzingGame] = useState(false);
                const [analysisError, setAnalysisError] = useState('');

                const calculateWinner = (squares) => {
                    const lines = [
                        [0, 1, 2], [3, 4, 5], [6, 7, 8],
                        [0, 3, 6], [1, 4, 7], [2, 5, 8],
                        [0, 4, 8], [2, 4, 6],
                    ];
                    for (let i = 0; i < lines.length; i++) {
                        const [a, b, c] = lines[i];
                        if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
                            return squares[a];
                        }
                    }
                    if (squares.every(square => square !== null)) return 'Draw';
                    return null;
                };

                useEffect(() => {
                    if (winner) {
                        if (winner === 'Draw') setStatusMessage('Ничья!');
                        else setStatusMessage(`Победил ${winner}!`);
                    } else {
                        setStatusMessage(`Ход игрока ${isXTurn ? 'X' : 'O'}`);
                    }
                }, [winner, isXTurn]);

                const handleClick = (index) => {
                    if (board[index] || winner) return;
                    const newBoard = [...board];
                    newBoard[index] = isXTurn ? 'X' : 'O';
                    setBoard(newBoard);
                    const gameWinner = calculateWinner(newBoard);
                    if (gameWinner) setWinner(gameWinner);
                    else setIsXTurn(!isXTurn);
                };

                const resetGame = () => {
                    setBoard(Array(9).fill(null));
                    setIsXTurn(true);
                    setWinner(null);
                    setStatusMessage('Ход игрока X');
                    setGameAnalysis('');
                    setAnalysisError('');
                };

                const handleAnalyzeGame = async () => {
                    if (!winner) return;
                    setIsAnalyzingGame(true);
                    setGameAnalysis('');
                    setAnalysisError('');
                    const boardString = board.map(cell => cell || '_').join(', ');
                    const prompt = `Ты — веселый спортивный комментатор. Только что завершилась партия в крестики-нолики. Результат: ${winner === 'Draw' ? 'Ничья' : `Победил ${winner}`}. Финальное состояние доски (пустые клетки обозначены '_'): ${boardString}. Напиши очень короткий (1-2 предложения), забавный или едкий комментарий об этой эпической битве.`;
                    try {
                        const analysis = await generateTextFromGemini(prompt);
                        setGameAnalysis(analysis);
                    } catch (error) {
                        setAnalysisError(`Ошибка анализа: ${error.message}`);
                        console.error("Ошибка при анализе игры:", error);
                    } finally {
                        setIsAnalyzingGame(false);
                    }
                };

                return (
                    <div className="tic-tac-toe-game">
                        <div className="status">{statusMessage}</div>
                        <div className="board">
                            {board.map((cell, index) => (
                                <button
                                    key={index}
                                    className="cell"
                                    onClick={() => handleClick(index)}
                                    disabled={!!cell || !!winner}
                                >
                                    {cell}
                                </button>
                            ))}
                        </div>
                        {winner && (
                            <div className="winner-section">
                                <div className={`winner ${winner === 'Draw' ? 'draw' : ''}`}>
                                </div>
                                <button onClick={resetGame}>Новая игра</button>
                                <div className="gemini-feature" style={{ marginTop: '10px' }}>
                                    <button onClick={handleAnalyzeGame} disabled={isAnalyzingGame}>
                                        {isAnalyzingGame ? 'Анализ...' : '✨ Проанализировать игру'}
                                    </button>
                                    {isAnalyzingGame && <div className="loading-indicator" style={{fontSize: '0.9em', padding: '5px'}}>Идет анализ...</div>}
                                    {analysisError && <div className="error-indicator" style={{fontSize: '0.9em', padding: '5px'}}>{analysisError}</div>}
                                    {gameAnalysis && !isAnalyzingGame && <div className="gemini-analysis">{gameAnalysis}</div>}
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            // --- Компонент Чата ---
            const Chat = ({ conversationId }) => {
                const [newMessage, setNewMessage] = useState('');
                const [selectedImageFile, setSelectedImageFile] = useState(null);
                const [imagePreviewUrl, setImagePreviewUrl] = useState(null);
                const [replyTo, setReplyTo] = useState(null); 
                const [isGeneratingPhrase, setIsGeneratingPhrase] = useState(false);
                const [phraseError, setPhraseError] = useState('');

                const fileInputRef = useRef(null);
                const messagesEndRef = useRef(null);
                const tanQueryClient = useTanQueryClient();

                const fetchMessages = async () => {
                    const response = await fetch(`${API_BASE_URL}/api/conversations/${conversationId}/messages`);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ message: 'Не удалось получить детали ошибки' }));
                        throw new Error(`Ошибка загрузки сообщений: ${response.status} - ${errorData.message || response.statusText}`);
                    }
                    return response.json();
                };

                const { data: messages = [], error, isLoading } = useQuery(
                    ['messages', conversationId],
                    fetchMessages,
                    { onError: (err) => console.error('Ошибка React Query (fetchMessages):', err.message) }
                );

                const sendMessageMutation = useMutation(
                    async (formData) => {
                        const response = await fetch(`${API_BASE_URL}/api/send-message`, {
                            method: 'POST',
                            body: formData,
                        });
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ message: 'Не удалось получить детали ошибки' }));
                            throw new Error(`Ошибка отправки сообщения: ${response.status} - ${errorData.message || response.statusText}`);
                        }
                        return response.json();
                    },
                    {
                        onSuccess: () => tanQueryClient.invalidateQueries(['messages', conversationId]),
                        onError: (err) => {
                            console.error('Ошибка React Query (sendMessage):', err.message);
                            alert(`Не удалось отправить сообщение: ${err.message}`);
                        }
                    }
                );

                useEffect(() => {
                    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
                }, [messages]);

                // Проверяем наличие useSwipeable перед использованием
                const handlers = useSwipeable ? useSwipeable({
                    onSwipedRight: (eventData) => {
                        const messageId = eventData.event.target.closest('.message')?.dataset.messageId;
                        if (messageId) {
                            const message = messages.find((msg) => msg._id === messageId || msg.id === messageId);
                            if (message) setReplyTo(message);
                        }
                    },
                    trackMouse: true,
                    preventScrollOnSwipe: true,
                }) : {}; // Если useSwipeable не определен, передаем пустой объект

                const handleImageChange = (e) => {
                    const file = e.target.files?.[0];
                    if (file) {
                        setSelectedImageFile(file);
                        setImagePreviewUrl(URL.createObjectURL(file));
                    }
                };
                
                const removeSelectedImage = () => {
                    setSelectedImageFile(null);
                    setImagePreviewUrl(null);
                    if (fileInputRef.current) fileInputRef.current.value = "";
                };

                const handleSend = () => {
                    if (!newMessage.trim() && !selectedImageFile) return;
                    const formData = new FormData();
                    if (selectedImageFile) formData.append('image', selectedImageFile);
                    formData.append('text', newMessage);
                    formData.append('userId', 'currentUser'); 
                    formData.append('conversationId', conversationId);
                    if (replyTo) formData.append('replyToId', replyTo._id || replyTo.id);
                    sendMessageMutation.mutate(formData);
                    setNewMessage('');
                    removeSelectedImage();
                    setReplyTo(null);
                };
                
                const triggerFileInput = () => fileInputRef.current?.click();

                const handleGenerateChatMessage = async () => {
                    setIsGeneratingPhrase(true);
                    setPhraseError('');
                    const prompt = "Придумай короткую (несколько слов), забавную или немного дерзкую фразу, которую можно отправить в чат во время игры в крестики-нолики. Будь креативным!";
                    try {
                        const phrase = await generateTextFromGemini(prompt);
                        setNewMessage(phrase); 
                    } catch (error) {
                        setPhraseError(`Ошибка генерации: ${error.message}`);
                        console.error("Ошибка при генерации фразы для чата:", error);
                    } finally {
                        setIsGeneratingPhrase(false);
                    }
                };

                if (!useSwipeable) {
                    console.warn("Хук useSwipeable не доступен. Функция свайпа будет отключена.");
                }

                if (isLoading) return <div className="loading-indicator">Загрузка сообщений...</div>;
                if (error) return <div className="error-indicator">Ошибка чата: {error.message}</div>;

                return (
                    <div className="chat-container">
                        <div className="chat-messages" {...handlers}>
                            {messages.map((msg) => (
                                <div
                                    key={msg._id || msg.id}
                                    className={`message ${msg.userId === 'currentUser' ? 'sent' : 'received'}`}
                                    data-message-id={msg._id || msg.id}
                                >
                                    {msg.replyToId && messages.find(m => (m._id || m.id) === msg.replyToId) && (
                                        <div className="reply-preview" style={{backgroundColor: 'rgba(0,0,0,0.05)', padding: '5px', marginBottom: '5px', borderRadius: '5px', fontSize: '0.8em'}}>
                                            <i>Ответ на: {messages.find(m => (m._id || m.id) === msg.replyToId)?.text?.substring(0,30) || 'Изображение'}...</i>
                                        </div>
                                    )}
                                    {msg.text && <p>{msg.text}</p>}
                                    {msg.imageUrl && (
                                        <img
                                            src={msg.imageUrl.startsWith('http') ? msg.imageUrl : `${API_BASE_URL}${msg.imageUrl}`}
                                            alt="Изображение в сообщении"
                                            onError={(e) => {
                                                console.error('Ошибка загрузки изображения:', msg.imageUrl);
                                                e.target.alt = 'Не удалось загрузить изображение';
                                                e.target.src = 'https://placehold.co/200x100/eee/ccc?text=Ошибка';
                                            }}
                                        />
                                    )}
                                </div>
                            ))}
                            <div ref={messagesEndRef} />
                        </div>
                        <div className="chat-input-area">
                            {replyTo && (
                                <div className="reply-preview">
                                    <span>Ответ на: {replyTo.text?.substring(0, 30) || 'Изображение'}...</span>
                                    <button onClick={() => setReplyTo(null)}>✕</button>
                                </div>
                            )}
                            {imagePreviewUrl && (
                                <div className="image-preview-container">
                                    <img src={imagePreviewUrl} alt="Предпросмотр изображения" />
                                    <button onClick={removeSelectedImage} className="remove-image-btn">✕</button>
                                </div>
                            )}
                            {phraseError && <div className="error-indicator" style={{fontSize: '0.9em', paddingBottom: '5px'}}>{phraseError}</div>}
                            <div className="chat-input-controls">
                                <input type="file" accept="image/*" ref={fileInputRef} onChange={handleImageChange} />
                                <button type="button" onClick={triggerFileInput} className="file-upload-label" title="Прикрепить изображение">📎</button>
                                <input
                                    type="text"
                                    value={newMessage}
                                    onChange={(e) => setNewMessage(e.target.value)}
                                    placeholder={isGeneratingPhrase ? "✨ Думаю..." : "Напишите сообщение..."}
                                    onKeyPress={(e) => e.key === 'Enter' && !e.shiftKey ? (handleSend(), e.preventDefault()) : null}
                                    disabled={isGeneratingPhrase}
                                />
                                <button onClick={handleGenerateChatMessage} disabled={isGeneratingPhrase} className="gemini-chat-btn" title="✨ Сгенерировать фразу">
                                    {isGeneratingPhrase ? '...' : '✨'}
                                </button>
                                <button onClick={handleSend} disabled={sendMessageMutation.isLoading || isGeneratingPhrase}>
                                    {sendMessageMutation.isLoading ? '...' : '➤'}
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            const App = () => {
                const [queryClient] = useState(() => new QueryClient({
                    defaultOptions: {
                        queries: { refetchOnWindowFocus: false, retry: 1 },
                    },
                }));

                return (
                    <StrictMode>
                        <QueryClientProvider client={queryClient}>
                            <div className="app-container">
                                <h1>Крестики-Нолики</h1>
                                <TicTacToeGame />
                                <h2 className="chat-section-title">Общий чат</h2>
                                <Chat conversationId="global-game-chat" />
                            </div>
                        </QueryClientProvider>
                    </StrictMode>
                );
            };

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<App />);
        };
    </script>
</body>
</html>
